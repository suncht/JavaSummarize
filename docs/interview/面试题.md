1. jvm垃圾回收的时候如何确定垃圾？ 是否知道什么是GC Roots？
2. 你说你做过jvm调试和参数配置，请问如何盘点查看jvm系统默认值？
3. 你平时工作用过的jvm常用基本配置参数有哪些？
4. 分布式锁解决缓存重建并发的问题
5. 事务的隔离级别
6. MySQL实现可重复读的原理、索引
7. 数据库主从同步情况下，如果从库同步主库的数据延迟比计较高，怎么才能在写到主库后立刻能够读取到数据。
    解决方案：使用缓存
8. 加锁时候，用什么锁对象时内存占用最小？
9. Collections.sort使用的排序算法
10. AQS、线程池、ThreadLocal原理
11. 分布式限流有哪些方案，以及用线程池进行限流的限流的缺陷是什么？
12. JVM模型，JMM模型，垃圾回收机制、垃圾收集器
13. 项目中使用了哪些设计模式？
14. synchronized和reentrantlock的区别，偏向锁/轻量级锁/重量级锁的原理，能否从偏向锁直接升级到重量级锁？
    > 偏向锁：锁只被一个线程持有
    > 轻量级锁：不同线程交替持有锁
    > 多线程竞争锁：重量级锁
    > 
15. 线程池原理和参数配置，jvm调优，堆大小的设计，多线程的线程数的设置，volatile原理
16. redis的数据类型，比如要获取一个有序列表的前10个元素应该用什么命令？
17. B+树的原理，Innodb引擎和MyIsam引擎的区别和使用场景，MySQL的分库分表？
18. mq的可靠性和顺序性
19. ES插入数据的原理、倒排索引
20. redis的数据类型，每个数据类型的底层实现，跳表数据结构如何插入数据，如何扩容？



**为什么CMS两次标记时要 stop the world（阿里面试）**
1、CMS及其执行过程？

       CMS，全称Concurrent Mark and Sweep，用于对年老代进行回收，目标是尽量减少应用的暂停时间，减少full gc发生的机率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代。CMS并非没有暂停，而是用两次短暂停来替代串行标记整理算法的长暂停。

    内外的设置正常收集周期是这样的：

    1）CMS-initial-mark 初始标记
　　2）CMS-concurrent-mark 并发标记的
　　3）CMS-concurrent-preclean 执行预清理   注: 相当于两次 concurrent-mark. 因为上一次c mark，太长.会有很多 changed object 出现.先干掉这波.到最好的 stop the world 的 remark 阶段,changed object 会少很多.
　　4）CMS-concurrent-abortable-preclean 执行可中止预清理  
　　5）CMS-remark 重新标记
　　6）CMS-concurrent-sweep 并发清除
　　7）CMS-concurrent-reset 并发重设状态等待下次CMS的触发

其中，CMS-initial-mark和CMS-remark会stop-the-world。

2、为什么 CMS两次标记时要 stop the world？
      我们知道垃圾回收首先是要经过标记的。对象被标记后就会根据不同的区域采用不同的收集方法。看上去很完美的一件事情，其实并不然。 
  大家有没有想过一件事情，当虚拟机完成两次标记后，便确认了可以回收的对象。但是，垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的。所以问题就出在这里，当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize()方法，因此回收的时候就会回收这个不该回收的对象。 
  虚拟机的解决方法就是在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。 
  这些特定的指令位置主要在：
    1、循环的末尾
    2、方法临返回前 / 调用方法的call指令后
    3、可能抛异常的位置
